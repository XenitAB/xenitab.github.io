"use strict";(globalThis.webpackChunkhome=globalThis.webpackChunkhome||[]).push([[7949],{888(e,t,n){n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"xenit-style-guide/containers","title":"Containers","description":"This page documents best practices when publishing open source applications that are meant to run in Kubernetes. Refer to the developer guide for documentation about how to run and manage applications in Kubernetes.","source":"@site/docs/xenit-style-guide/containers.md","sourceDirName":"xenit-style-guide","slug":"/xenit-style-guide/containers","permalink":"/docs/xenit-style-guide/containers","draft":false,"unlisted":false,"editUrl":"https://github.com/xenitab/xenitab.github.io/edit/main/docs/xenit-style-guide/containers.md","tags":[],"version":"current","frontMatter":{"id":"containers","title":"Containers"},"sidebar":"docs","previous":{"title":"Azure DNS Migration Playbook","permalink":"/docs/xks/operator-guide/ingress-nginx deprecation/azure-dns-migration-playbook"},"next":{"title":"Golang","permalink":"/docs/xenit-style-guide/golang"}}');var o=n(4848),i=n(8453);const r={id:"containers",title:"Containers"},a=void 0,c={},l=[{value:"Docker",id:"docker",level:2},{value:"Helm",id:"helm",level:2}];function h(e){const t={a:"a",code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsxs)(t.p,{children:["This page documents best practices when publishing open source applications that are meant to run in Kubernetes. Refer to the ",(0,o.jsx)(t.a,{href:"../xks/developer-guide/introduction",children:"developer guide"})," for documentation about how to run and manage applications in Kubernetes."]}),"\n",(0,o.jsx)(t.h2,{id:"docker",children:"Docker"}),"\n",(0,o.jsx)(t.p,{children:"TBD"}),"\n",(0,o.jsx)(t.h2,{id:"helm",children:"Helm"}),"\n",(0,o.jsxs)(t.p,{children:["Helm has since version 3.8.0 supported storing Helm charts in OCI registires. This solution has a lot of benefits over the old Helm registry and for this reason should be the only way Helm charts are published in Xenit open source projects. The Helm chart OCI artifact should have the same name as the Docker image which the application produces and share the same version number. To avoid name conflicts however the Helm chart should be prefixed with ",(0,o.jsx)(t.code,{children:"helm-charts/"}),". Refer to the project ",(0,o.jsx)(t.a,{href:"https://github.com/XenitAB/node-ttl",children:"node-ttl"})," for an example. It has both the Docker image ",(0,o.jsx)(t.a,{href:"https://github.com/XenitAB/node-ttl/pkgs/container/node-ttl",children:"node-ttl"})," and the Helm chart ",(0,o.jsx)(t.a,{href:"https://github.com/XenitAB/node-ttl/pkgs/container/helm-charts%2Fnode-ttl",children:"helm-charts/node-ttl"})," stored in Github container registries."]}),"\n",(0,o.jsx)(t.p,{children:"Below is an GitHub action which builds and pushes a chart to GitHub container registry."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-yaml",children:'name: release\non:\n  release:\n    types: [published]\njobs:\n  helm:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Clone repo\n        uses: actions/checkout@v2\n      - name: Install Helm\n        uses: azure/setup-helm@v1\n      - name: Get GitHub Tag\n        id: get_tag\n        run: |\n          echo "::set-output name=tag::${GITHUB_REF#refs/tags/}"\n      - name: Publish Helm charts\n        run: |\n          cd charts\n          helm registry login -u ${{ github.repository_owner }} -p ${{ secrets.GITHUB_TOKEN }} ghcr.io\n          helm package --app-version ${{ steps.get_tag.outputs.tag }} --version ${{ steps.get_tag.outputs.tag }} node-ttl\n          helm push node-ttl-${{ steps.get_tag.outputs.tag }}.tgz oci://ghcr.io/xenitab/helm-charts\n'})})]})}function u(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453(e,t,n){n.d(t,{R:()=>r,x:()=>a});var s=n(6540);const o={},i=s.createContext(o);function r(e){const t=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);