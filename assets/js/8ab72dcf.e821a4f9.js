"use strict";(globalThis.webpackChunkhome=globalThis.webpackChunkhome||[]).push([[8470],{7266(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>h});const i=JSON.parse('{"id":"xks/developer-guide/networking","title":"Networking","description":"Network Policies","source":"@site/docs/xks/developer-guide/networking.md","sourceDirName":"xks/developer-guide","slug":"/xks/developer-guide/networking","permalink":"/docs/xks/developer-guide/networking","draft":false,"unlisted":false,"editUrl":"https://github.com/xenitab/xenitab.github.io/edit/main/docs/xks/developer-guide/networking.md","tags":[],"version":"current","frontMatter":{"id":"networking","title":"Networking"},"sidebar":"docs","previous":{"title":"Observability","permalink":"/docs/xks/developer-guide/observability"},"next":{"title":"Working with XKF from Windows","permalink":"/docs/xks/developer-guide/wsl2"}}');var s=t(4848),a=t(8453),r=t(8180);const o={id:"networking",title:"Networking"},l=void 0,c={},h=[{value:"Network Policies",id:"network-policies",level:2},{value:"Examples",id:"examples",level:3},{value:"Allow Internet Egress",id:"allow-internet-egress",level:4},{value:"Allow Ingress Nginx",id:"allow-ingress-nginx",level:4},{value:"Allow Cross Namespace",id:"allow-cross-namespace",level:4},{value:"Debugging",id:"debugging",level:3},{value:"Ingress and Gateway API",id:"ingress-and-gateway-api",level:2},{value:"Gateway API",id:"gateway-api",level:3},{value:"Envoy Gateway",id:"envoy-gateway",level:3},{value:"Ingress Nginx Deprecation",id:"ingress-nginx-deprecation",level:3},{value:"Ingress (Legacy)",id:"ingress-legacy",level:2},{value:"Public and Private Ingress",id:"public-and-private-ingress",level:3},{value:"External Routing",id:"external-routing",level:3},{value:"Rate Limiting",id:"rate-limiting",level:3},{value:"Nginx Configuration",id:"nginx-configuration",level:3},{value:"Debugging",id:"debugging-1",level:3},{value:"Linkerd",id:"linkerd",level:2},{value:"Get Started",id:"get-started",level:3},{value:"FAQ",id:"faq",level:3},{value:"Is all network traffic encrypted?",id:"is-all-network-traffic-encrypted",level:4},{value:"What overhead can I expect?",id:"what-overhead-can-i-expect",level:4}];function d(e){const n={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h2,{id:"network-policies",children:"Network Policies"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/network-policies/",children:"Network Policies"})," in Kubernetes add the ability to allow and deny network traffic from specific pods and namespaces. Both\negress traffic from a Pod and ingress traffic to a Pod can be controlled. In a vanilla Kubernetes cluster all traffic between all namespaces is allowed by default. This is not the case in XKS. Out of\nthe box in XKS all tenant namespaces have a default deny rule added to them. This default deny rule will block any traffic going between namespaces. It will deny both ingress traffic from other\nnamespaces and egress traffic to other namespaces. All traffic within the namespace between Pods is allowed. The reasoning behind this setup is that Pods should not have more network access than they\nrequire to function, as it reduces the blast radius in case of an exploit."]}),"\n",(0,s.jsx)("img",{alt:"Default Deny Network Policy",src:(0,r.Ay)("img/assets/xks/developer-guide/network-policy-default-deny.jpg")}),"\n",(0,s.jsx)(n.p,{children:"The default deny Network Policy contains an exception for traffic destined to the cluster's DNS service. Without this exception DNS resolution would not work. The Pod selector in the Network Policy is\nempty, this means that the Network Policy will apply for all Pods in the namespace."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: default-deny\n  namespace: tenant\nspec:\n  egress:\n    - ports:\n        - port: 53\n          protocol: UDP\n      to:\n        - namespaceSelector: {}\n          podSelector:\n            matchLabels:\n              k8s-app: kube-dns\n    - to:\n        - podSelector: {}\n  ingress:\n    - from:\n        - podSelector: {}\n  podSelector: {}\n  policyTypes:\n    - Ingress\n    - Egress\n"})}),"\n",(0,s.jsxs)(n.p,{children:["There may come a time when you have to create new Network Policies to allow specific Pods traffic, as the default can be pretty restrictive. A common situation when this is required is when a Pod needs to\ncommunicate with the public Internet, or communicate with other Pods in other tenant namespaces. When creating new Network Policies make sure that you do not open up more than is actually required. A good source of example\nNetwork Policies is the Github repository ",(0,s.jsx)(n.a,{href:"https://github.com/ahmetb/kubernetes-network-policy-recipes",children:"kubernetes-network-policy-recipes"}),". It contains a lot of good examples with diagrams and\ndescriptions. The examples found there contain the most common use cases to make things simpler for you."]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:["A helpful tool when create new Network Policies is the ",(0,s.jsx)(n.a,{href:"https://editor.cilium.io/",children:"Cilium Network Policy Editor"}),"."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(n.h4,{id:"allow-internet-egress",children:"Allow Internet Egress"}),"\n",(0,s.jsx)(n.p,{children:"A common scenario is opening up traffic to the public Internet. A current limitation with Network Policies today is that it is not possible to create egress rules based on DNS names. This means that\nthe simplest solution is to allow traffic to all public IPs, as trying to resolve the DNS to an IP would only work short term."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-internet-egress\nspec:\n  egress:\n    - to:\n        - ipBlock:\n            cidr: 0.0.0.0/0\n  podSelector:\n    matchLabels:\n      app: foo\n  policyTypes:\n    - Egress\n"})}),"\n",(0,s.jsx)(n.h4,{id:"allow-ingress-nginx",children:"Allow Ingress Nginx"}),"\n",(0,s.jsx)(n.p,{children:"Traffic from the ingress controller has to be explicitly allowed as no traffic is allowed from outside the namespace by default. This can be considered a fail-safe to protect against accidental\nIngress creation, where an application is exposed to the Internet when that was not the intent. It is enough to allow ingress from the ingress controller even if the traffic actually originates from\noutside the cluster."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-ingress-controller\nspec:\n  ingress:\n    - from:\n        - namespaceSelector:\n            matchLabels:\n              name: ingress-nginx\n  podSelector:\n    matchLabels:\n      app: foo\n  policyTypes:\n    - Ingress\n"})}),"\n",(0,s.jsx)(n.h4,{id:"allow-cross-namespace",children:"Allow Cross Namespace"}),"\n",(0,s.jsx)(n.p,{children:"When allowing network traffic across tenant namespaces considerations have to be made for the default deny Network Policy in both namespaces. An allow rule has to be created to allow the source\nnamespace (the side initating the connection) to send traffic to the destination namespace. The destination namespace has to allow traffic from the source namespace. The first Network Policy should be used\nin the source namespace and the second should be used in the destination namespace."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-egress-to-destination\n  namespace: source\nspec:\n  egress:\n    - to:\n        - namespaceSelector:\n            matchLabels:\n              name: destination\n          podSelector:\n            matchLabels:\n              app: bar\n  podSelector:\n    matchLabels:\n      app: foo\n  policyTypes:\n    - Egress\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: networking.k8s.io/v1\nkind: NetworkPolicy\nmetadata:\n  name: allow-ingress-from-source\n  namespace: destination\nspec:\n  ingress:\n    - from:\n        - namespaceSelector:\n            matchLabels:\n              name: source\n          podSelector:\n            matchLabels:\n              app: foo\n  podSelector:\n    matchLabels:\n      app: bar\n  policyTypes:\n    - Ingress\n"})}),"\n",(0,s.jsx)(n.h3,{id:"debugging",children:"Debugging"}),"\n",(0,s.jsx)(n.p,{children:"TBD"}),"\n",(0,s.jsx)(n.h2,{id:"ingress-and-gateway-api",children:"Ingress and Gateway API"}),"\n",(0,s.jsxs)(n.p,{children:["XKS uses the ",(0,s.jsx)(n.a,{href:"https://gateway-api.sigs.k8s.io/",children:"Kubernetes Gateway API"})," as the modern standard for managing ingress traffic, with ",(0,s.jsx)(n.a,{href:"https://gateway.envoyproxy.io/",children:"Envoy Gateway"})," as the implementation. Gateway API is the successor to the traditional Ingress API and provides a more powerful, flexible, and extensible way to configure traffic routing into your Kubernetes cluster."]}),"\n",(0,s.jsx)(n.h3,{id:"gateway-api",children:"Gateway API"}),"\n",(0,s.jsx)(n.p,{children:"The Gateway API provides:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Role-oriented design"}),": Clear separation between infrastructure providers, cluster operators, and application developers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Enhanced expressiveness"}),": Native support for header-based routing, traffic splitting, request mirroring, and more"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Better extensibility"}),": Uses typed Kubernetes resources instead of implementation-specific annotations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Protocol support"}),": Built-in support for HTTP, HTTPS, TCP, TLS, UDP, and GRPC"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Future-proof"}),": Officially maintained by Kubernetes SIG Network and graduated to GA status"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For comprehensive documentation on using Gateway API in XKS, including examples, advanced features, and usage patterns, see the ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/xks/operator-guide/ingress-nginx%20deprecation/gateway-api",children:"Gateway API Developer Guide"})}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Refer to the official ",(0,s.jsx)(n.a,{href:"https://gateway-api.sigs.k8s.io/",children:"Gateway API documentation"})," for the complete specification and community resources."]}),"\n",(0,s.jsx)(n.h3,{id:"envoy-gateway",children:"Envoy Gateway"}),"\n",(0,s.jsxs)(n.p,{children:["XKS uses ",(0,s.jsx)(n.a,{href:"https://gateway.envoyproxy.io/",children:"Envoy Gateway"})," as the implementation of the Gateway API standard. Envoy Gateway leverages ",(0,s.jsx)(n.a,{href:"https://www.envoyproxy.io/",children:"Envoy Proxy"}),", a modern, cloud-native proxy designed for high-performance scenarios."]}),"\n",(0,s.jsx)(n.p,{children:"Key capabilities:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Dynamic configuration without downtime"}),"\n",(0,s.jsx)(n.li,{children:"Native Gateway API support"}),"\n",(0,s.jsx)(n.li,{children:"Advanced traffic management (circuit breaking, sophisticated retries, multiple load balancing algorithms)"}),"\n",(0,s.jsx)(n.li,{children:"Rich observability (metrics, distributed tracing, structured logging)"}),"\n",(0,s.jsx)(n.li,{children:"Service mesh ready architecture"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["For details on Envoy Gateway features, policies, observability, performance tuning, and troubleshooting, see the ",(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/xks/operator-guide/ingress-nginx%20deprecation/envoy-gateway",children:"Envoy Gateway Guide"})}),"."]}),"\n",(0,s.jsx)(n.p,{children:"For Envoy internals and advanced configuration, refer to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://gateway.envoyproxy.io/",children:"Envoy Gateway Documentation"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://www.envoyproxy.io/docs",children:"Envoy Proxy Documentation"})}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"ingress-nginx-deprecation",children:"Ingress Nginx Deprecation"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"\u26a0\ufe0f IMPORTANT"}),": The traditional Ingress API with Nginx Ingress Controller is deprecated in XKS and will be removed in a future release."]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"What this means:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Existing Ingress resources continue to work during the migration period"}),"\n",(0,s.jsx)(n.li,{children:"All new applications should use Gateway API"}),"\n",(0,s.jsx)(n.li,{children:"Migration assistance is available from the XKS platform team"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Migration Resources:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/xks/operator-guide/ingress-nginx%20deprecation/ingress-nginx-retiring",children:"Ingress Nginx Migration Guide"})})," - Complete deprecation information, timelines, step-by-step migration instructions, and annotation mapping"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:(0,s.jsx)(n.a,{href:"/docs/xks/operator-guide/ingress-nginx%20deprecation/gateway-api#migration-from-ingress",children:"Gateway API Guide"})})," - Side-by-side Ingress to HTTPRoute examples"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"For official deprecation information and Kubernetes community guidance:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://kubernetes.io/blog/2023/10/31/gateway-api-ga/",children:"Gateway API GA Announcement"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://gateway-api.sigs.k8s.io/guides/migrating-from-ingress/",children:"Official Gateway API Migration Guide"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"ingress-legacy",children:"Ingress (Legacy)"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": This section documents the legacy Ingress API for reference. New applications should use ",(0,s.jsx)(n.a,{href:"#gateway-api",children:"Gateway API"})," instead."]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/services-networking/ingress/",children:"Ingress"})," in Kubernetes is used to allow network traffic from the outside the cluster to reach Pods inside the cluster. Ingress works\nas a layer on top of Kubernetes Services by exposing the Service with a hostname. All Ingress traffic is Layer 7 routed, meaning that traffic is routed based on the host header in the HTTP request. This\nalso means that Ingress only works with HTTP traffic. Doing it this way means that only a single load balancer is required reducing cost compared to running multiple load balancers, one per Ingress."]}),"\n",(0,s.jsx)("img",{alt:"Ingress Overview",src:(0,r.Ay)("img/assets/xks/developer-guide/ingress-overview.jpg")}),"\n",(0,s.jsxs)(n.p,{children:["XKS comes with everything pre-configured for Ingress to work. The cluster will either have a single ",(0,s.jsx)(n.a,{href:"https://kubernetes.github.io/ingress-nginx/",children:"Nginx Ingress Controller"})," which is exposed to the\npublic Internet or two controllers where one is public and one is private. On top of that the cluster is configured with ",(0,s.jsx)(n.a,{href:"https://github.com/kubernetes-sigs/external-dns",children:"External DNS"}),"(which creates\nDNS records) and ",(0,s.jsx)(n.a,{href:"https://cert-manager.io/docs/",children:"Cert Manager"})," (which deals with certificate creation and renewal). Together these three tools offer an automated solution where the complexity of DNS and\ncertificates are not handled by the application. The recommendation is to always enable TLS for all Ingress resources no matter how small the service is. Updating a certificate is\nquick and easy so there is no reason not to do this. Every XKS cluster comes with a preconfigured Cluster Issuer which will provision certificates from ",(0,s.jsx)(n.a,{href:"https://letsencrypt.org/",children:"Let's Encrypt"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["Start off by creating a Certificate resource for your Ingress. It is possible to have Cert Manager automatically create a Certificate when an Ingress resource is created. This however has the\ndownside that every Ingress resource will receive its own Certificate. Lets Encrypt has ",(0,s.jsx)(n.a,{href:"https://letsencrypt.org/docs/rate-limits/",children:"rate limits"})," for the same domain, if one were to create a\nCertificate per ingress that rate limit would be hit pretty quickly. For this reason it is better to create a shared Certificate per tenant namespace with multiple DNS names instead. Each DNS name will be\npresent in the Certificate so that it can be used for multiple Ingress resources. When the Certificate is provisioned it will be written to a Secret."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: cert-manager.io/v1\nkind: Certificate\nmetadata:\n  name: shared\n  namespace: tenant\nspec:\n  issuerRef:\n    group: cert-manager.io\n    kind: ClusterIssuer\n    name: letsencrypt\n  dnsNames:\n    - app-one.example.com\n    - app-two.example.com\n  secretName: shared-cert\n"})}),"\n",(0,s.jsxs)(n.p,{children:["To complete the ingress configuration an Ingress resource has to be created. The Ingress resource defines the Service where the traffic should be routed to and the DNS name which should resolve to\nthat Service. An additional configuration is the TLS configuration which configures the certificate to use. Cert Manager writes the certificate data to a Secret which is configured in the Certificate\n",(0,s.jsx)(n.code,{children:"secretName"}),". That same Secret should be referenced in the TLS configuration. A DNS record will be automatically created when the Ingress is applied to the cluster."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: app-one\n  namespace: tenant\nspec:\n  rules:\n    - host: app-one.example.com\n      http:\n        paths:\n          - path: /\n            backend:\n              service:\n                name: app-one\n                port:\n                  name: http\n  tls:\n    - hosts:\n        - app-one.example.com\n      secretName: shared-cert\n"})}),"\n",(0,s.jsx)(n.h3,{id:"public-and-private-ingress",children:"Public and Private Ingress"}),"\n",(0,s.jsxs)(n.p,{children:["By default an XKS cluster will deploy a single public Ingress controller. All Ingress resources will be routed with a public IP and therefore exposed to the public Internet. It is however also possible to\ncreate private Ingress resources which are only exposed through an IP that is private to the virtual network in which the Kubernetes cluster is deployed. This is an opt in feature\nas two load balancing services are needed. Making an Ingress private is simple when the private Ingress feature is enabled. All that is required is that the Ingress class has to be set\nto ",(0,s.jsx)(n.code,{children:"nginx-private"}),", this makes sure that the resource is only served through the private IP."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: app-one\n  namespace: tenant\nspec:\n  ingressClassName: nginx-private\n  rules:\n    - host: app-one.example.com\n      http:\n        paths:\n          - path: /\n            backend:\n              service:\n                name: app-one\n                port:\n                  name: http\n  tls:\n    - hosts:\n        - app-one.example.com\n      secretName: shared-cert\n"})}),"\n",(0,s.jsx)(n.h3,{id:"external-routing",children:"External Routing"}),"\n",(0,s.jsx)(n.p,{children:"There is no requirement that the destination for an Ingress resource has to be served from within the cluster. It is possible to route Ingress traffic either to endpoints outside of the\ncloud provider or to another service that is only accessible from within the private network. Using the XKS Ingress instead of a separate solution has it's benefits in these situations,\nas DNS record creation and certificate management is already setup to work. A typical use case may be during a migration period when XKS and another solution may exist in parallel.\nAll traffic can enter through XKS but then be forwarded to the external destination. The service endpoints can be updated as applications are migrated to run inside XKS instead of outside."}),"\n",(0,s.jsx)(n.p,{children:"A Service resource is required to configure the destination of the traffic. There are two options available in Kubernetes when directing traffic outside of the cluster. The first option is to\ncreate a Service of type ExternalName which specifies a host name which the Service should write to. When a request is made to the Service the given external name IP will be resolved and the\nrequest will be sent to that destination."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Service\nmetadata:\n  name: to-external\nspec:\n  type: ExternalName\n  externalName: example.com\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The other option is to create a Service which routes to a static IP. This is implemented with a Serivce without an external name or label selector, then also creating an Endpoint for the Service.\nThis way the Service will only resolve to the static IP given, in this case the static IP is ",(0,s.jsx)(n.code,{children:"1.2.3.4"})," and the port is ",(0,s.jsx)(n.code,{children:"443"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Service\nmetadata:\n  name: to-external\nspec:\n  ports:\n    - protocol: TCP\n      port: 443\n---\napiVersion: v1\nkind: Endpoints\nmetadata:\n  name: to-external\nsubsets:\n  - addresses:\n      - ip: 1.2.3.4\n    ports:\n      - port: 443\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The Serivce resources only solve half the problem as they are only accessible within the cluster. They have to be exposed with an Ingress resource to solve the other half, so that on host name\ncan be translated to another. The example assume that all traffic is expected to be HTTPS on both ends. The Ingress below exposes the Service named ",(0,s.jsx)(n.code,{children:"to-external"})," on the port ",(0,s.jsx)(n.code,{children:"443"})," with the host\nname ",(0,s.jsx)(n.code,{children:"forward.xenit.io"}),". It also assumes that a TLS Secret exists which is valid for the Ingress host name."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:'apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: forward-traffic\n  annotations:\n    nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"\n    nginx.ingress.kubernetes.io/upstream-vhost: "forward.xenit.io"\nspec:\n  rules:\n    - host: forward.xenit.io\n      http:\n        paths:\n          - pathType: Prefix\n            path: /\n            backend:\n              service:\n                name: forward-traffic\n                port:\n                  number: 443\n  tls:\n    - hosts:\n        - forward.xenit.io\n      secretName: to-external\n'})}),"\n",(0,s.jsxs)(n.p,{children:['The only major changes with the Ingress compared to a "normal" Ingress resource are the annotations. The annotations ',(0,s.jsx)(n.code,{children:'nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"'})," makes sure that the traffic\non the backend is sent as HTTPS traffic. Without this annotation there is a risk that the backend traffic could be transported as HTTP. The second annotations\n",(0,s.jsx)(n.code,{children:'nginx.ingress.kubernetes.io/upstream-vhost: "forward.xenit.io"'})," specifies the host header set in the upstream request. This annotation is not necessarily required for all external endpoints, but a lot\nof endpoints resolve their routing through layer 7 which means that the host header has to be set properly. A good practice is to set the annotation value to be the same as the external name."]}),"\n",(0,s.jsxs)(n.p,{children:["Another use case is to rewrite the request paths. This is possible through the ",(0,s.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/rewrite-target"})," which can allow for complex path modification logic. For details how to\nuse the annotation refer to the ",(0,s.jsx)(n.a,{href:"https://kubernetes.github.io/ingress-nginx/examples/rewrite/#rewrite-target",children:"documentation"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"rate-limiting",children:"Rate Limiting"}),"\n",(0,s.jsxs)(n.p,{children:["At times it is beneficial to rate limit the amount of requests that reach an internal application from the Internet. Rate limiting can be configured to act based on different parameters. Rate limiting\nis configured for an Ingress through the use of annotations. The annotations ",(0,s.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/limit-connections"})," limits the amount of concurrent connections allowed from a single source IP.\nThe other annotation ",(0,s.jsx)(n.code,{children:"nginx.ingress.kubernetes.io/limit-rps"})," sets a limit for the amount of requests per second that can be sent from a single source IP. These two strategies do not work together, you\nhave to decide on one or the other. Below is an example of a Ingress which limits the amount of concurrent connections."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: example\n  annotations:\n    nginx.ingress.kubernetes.io/limit-connections: 10\nspec:\n  rules:\n    - host: example.com\n      http:\n        paths:\n          - path: /\n            backend:\n              service:\n                name: example\n                port:\n                  name: http\n  tls:\n    - hosts:\n        - example.com\n      secretName: cert\n"})}),"\n",(0,s.jsxs)(n.p,{children:["For more information refer to the ",(0,s.jsx)(n.a,{href:"https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#rate-limiting",children:"official documentation"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"nginx-configuration",children:"Nginx Configuration"}),"\n",(0,s.jsxs)(n.p,{children:["It is useful to be aware of ",(0,s.jsx)(n.a,{href:"https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/annotations/#annotations",children:"annotation configuration"})," in the Nginx ingress controller.\nSometimes a specific Ingress requires custom behavior that is not default in the ingress controller, this behavior can be customized with the help of annotations for a specific Ingress resource.\nFor example, changing the client body buffer size may be useful if the header size in the expected requests is larger than the buffer."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: extensions/v1beta1\nkind: Ingress\nmetadata:\n  name: foo\n  namespace: bar\n  annotations:\n    nginx.ingress.kubernetes.io/client-body-buffer-size: 1M\nspec:\n  rules:\n    - host: foo.dev.example.com\n      http:\n        paths:\n          - backend:\n              serviceName: foo\n              servicePort: http\n  tls:\n    - hosts:\n        - foo.dev.example.com\n"})}),"\n",(0,s.jsx)(n.h3,{id:"debugging-1",children:"Debugging"}),"\n",(0,s.jsx)(n.p,{children:"Common networking problems include forgetting to set up egress or ingress rules that apply for your pods - or setting them up and then having the requirements change, which then causes connection errors."}),"\n",(0,s.jsxs)(n.p,{children:["Remember that you can inspect your network policies with ",(0,s.jsx)(n.code,{children:"kubectl get networkpolicies"}),". If you cannot see your policy there, verify if it is actually present in your ",(0,s.jsx)(n.code,{children:"kustomization.yaml"})," file."]}),"\n",(0,s.jsx)(n.h2,{id:"linkerd",children:"Linkerd"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://linkerd.io/",children:"Linkerd"})," is an optional service mesh that can be added to XKS. The component is opt-in as it adds a certain amount of overhead,\nso unless it has been requested Linkerd will not be present in XKS. A service mesh extends the networking functionality in a Kubernetes cluster. It is\nuseful when features such as end-to-end encryption or GRPC load balancing is required. Linkerd will automatically handle TCP loadbalancing so when\nGRPC is used Linkerd will detect this and loadbalance between instances of GRPC servers."]}),"\n",(0,s.jsxs)(n.p,{children:["Refer to the ",(0,s.jsx)(n.a,{href:"https://linkerd.io/2.10/overview/",children:"official documentation"})," for documentation that may be missing from this page."]}),"\n",(0,s.jsx)(n.p,{children:"Linkerd works by injecting a sidecar into every Pod which uses Linkerd. All network requests have to be sent through the sidecar which will then be\nresponsible for forwarding it. The sidecar will handle things like traffic encryption before sending the packets outside of the node."}),"\n",(0,s.jsx)("img",{alt:"Linkerd Overview",src:(0,r.Ay)("img/assets/xks/developer-guide/linkerd-overview.jpg")}),"\n",(0,s.jsx)(n.h3,{id:"get-started",children:"Get Started"}),"\n",(0,s.jsxs)(n.p,{children:["To enable sidecar injection the Pod has to have the annotation ",(0,s.jsx)(n.code,{children:"linkerd.io/inject: enabled"})," added to it. A common mistake when enabling Linkerd is\nthat the annotation is added to Deployment and not the Pod template, make sure that you do not do this as the sidecar will not be injected if\nyou do."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-yaml",children:"apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: linkerd-test\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: linkerd-test\n  template:\n    metadata:\n      annotations:\n        linkerd.io/inject: enabled\n      labels:\n        app: linkerd-test\n    spec:\n      containers:\n        - name: linkerd-test\n          image: alpine:latest\n          ports:\n            - containerPort: 8080\n              name: http\n              protocol: TCP\n"})}),"\n",(0,s.jsx)(n.p,{children:"Eventually a Pod should be created. An important detail is that there should be two containers in the Pod. One container should be the one defined in\nthe Deployment and the other one the Linkerd sidecar. This can be verified by getting the Pod's containers:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-shell",children:'$ kubectl get pods <POD_NAME> -o jsonpath="{.spec.containers[*].name}"\nlinkerd-test linkerd-proxy\n'})}),"\n",(0,s.jsx)(n.p,{children:"With the sidecar added all traffic going out of the container will automatically be proxied through the sidecar."}),"\n",(0,s.jsx)(n.h3,{id:"faq",children:"FAQ"}),"\n",(0,s.jsx)(n.h4,{id:"is-all-network-traffic-encrypted",children:"Is all network traffic encrypted?"}),"\n",(0,s.jsxs)(n.p,{children:["No, it depends on the traffic type and is something that should be verified rather than assumed. More information can be found in the ",(0,s.jsx)(n.a,{href:"https://linkerd.io/2.10/features/automatic-mtls/#",children:"Linkerd documentation"}),"."]}),"\n",(0,s.jsx)(n.h4,{id:"what-overhead-can-i-expect",children:"What overhead can I expect?"}),"\n",(0,s.jsx)(n.p,{children:"Each Pod will at a minimum consume an additional 10 MB due to the extra sidecar, and the number can grow as traffic increases."})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453(e,n,t){t.d(n,{R:()=>r,x:()=>o});var i=t(6540);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);