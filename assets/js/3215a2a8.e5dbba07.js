"use strict";(globalThis.webpackChunkhome=globalThis.webpackChunkhome||[]).push([[1e3],{1890(e,t,i){i.r(t),i.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>h,frontMatter:()=>r,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"xks/developer-guide/ci-cd/gitops","title":"GitOps a la XKS","description":"What is GitOps?","source":"@site/docs/xks/developer-guide/ci-cd/gitops.md","sourceDirName":"xks/developer-guide/ci-cd","slug":"/xks/developer-guide/ci-cd/gitops","permalink":"/docs/xks/developer-guide/ci-cd/gitops","draft":false,"unlisted":false,"editUrl":"https://github.com/xenitab/xenitab.github.io/edit/main/docs/xks/developer-guide/ci-cd/gitops.md","tags":[],"version":"current","frontMatter":{"id":"gitops","title":"GitOps a la XKS"},"sidebar":"docs","previous":{"title":"Continuous Delivery","permalink":"/docs/xks/developer-guide/ci-cd/cd"},"next":{"title":"Flux","permalink":"/docs/xks/developer-guide/ci-cd/flux"}}');var s=i(4848),o=i(8453),a=i(8180);const r={id:"gitops",title:"GitOps a la XKS"},l=void 0,p={},d=[{value:"What is GitOps?",id:"what-is-gitops",level:2},{value:"User story: Emilia updates an app",id:"user-story-emilia-updates-an-app",level:2},{value:"Applying to dev",id:"applying-to-dev",level:3},{value:"Applying to qa",id:"applying-to-qa",level:3},{value:"Application to prod is blocked",id:"application-to-prod-is-blocked",level:3},{value:"Second attempt applying to prod",id:"second-attempt-applying-to-prod",level:3}];function c(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h2,{id:"what-is-gitops",children:"What is GitOps?"}),"\n",(0,s.jsxs)(t.blockquote,{children:["\n",(0,s.jsxs)(t.p,{children:["GitOps works by using Git as a single source of truth for declarative infrastructure and applications. With GitOps, the use of software agents can alert on any divergence between Git and what is running in [an environment]. If there is a difference, Kubernetes reconcilers automatically update or rollback the cluster depending on what is appropriate. \u2010 ",(0,s.jsx)(t.em,{children:(0,s.jsx)(t.a,{href:"https://www.weave.works/technologies/gitops/",children:"Weave Works - Guide To GitOps"})})]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:'XKS supports GitHub and Azure DevOps with almost identical workflows. XKF refers to these as Git providers. For simplicity, we refer to their CI/CD automation as "pipelines". If you are using GitHub, whenever this text refers to "pipeline", think "GitHub Actions workflow". As you saw in the previous section, XKS comes with a set of pipelines that automatically detects app releases and promotes them through a series of environments. The allows both rapid iteration and strong validation of apps.'}),"\n",(0,s.jsxs)(t.p,{children:["XKS is built around ",(0,s.jsx)(t.a,{href:"https://trunkbaseddevelopment.com/",children:"trunk-based development"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"user-story-emilia-updates-an-app",children:"User story: Emilia updates an app"}),"\n",(0,s.jsxs)(t.p,{children:["In the previous section, we looked at deploying our first app to Kubernetes using a fully automatic flow. But what actually happened in that flow? This section tells the story about a developer called Emilia. She has updated an app packaged as a container image. A pipeline in the app's repository has just tagged the container image as ",(0,s.jsx)(t.code,{children:"a8b91c33"})," and uploaded it to a container registry."]}),"\n",(0,s.jsxs)(t.p,{children:["The GitOps repository for Emilia's app has a ",(0,s.jsx)(t.code,{children:"gitops-promotion.yaml"})," that looks like this (for much more details, see the ",(0,s.jsx)(t.a,{href:"https://github.com/XenitAB/gitops-promotion",children:"gitops-promotion"})," readme):"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-yaml",children:"prflow: per-app\nenvironments:\n  - env: dev\n    auto: true\n  - env: qa\n    auto: true\n  - env: prod\n    auto: false\n"})}),"\n",(0,s.jsxs)(t.p,{children:["The ",(0,s.jsx)(t.code,{children:"dev"})," and ",(0,s.jsx)(t.code,{children:"qa"})," environments have ",(0,s.jsx)(t.code,{children:"auto: true"})," which means that new releases will be automatically applied, while the ",(0,s.jsx)(t.code,{children:"prod"})," environment is configured with ",(0,s.jsx)(t.code,{children:"auto: false"}),". This means that pull requests must be merged by a human, presumably one that has verified that the update worked as expected in previous environments. The GitOps repository is configured to require checks on pull requests to pass in order to allow merge."]}),"\n",(0,s.jsx)(t.h3,{id:"applying-to-dev",children:"Applying to dev"}),"\n",(0,s.jsx)(t.p,{children:"The flow is fully automatic and is triggered by the container image upload."}),"\n",(0,s.jsx)("img",{alt:"Apply to dev",src:(0,a.Ay)("img/assets/xks/developer-guide/developer-flow-apply-dev.jpg")}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["The ",(0,s.jsx)("img",{src:(0,a.Ay)("img/gitops/acr-icon.png"),style:{width:"1em"}})," / ",(0,s.jsx)("img",{src:(0,a.Ay)("img/gitops/ecr-icon.png"),style:{width:"1em"}})," container image upload triggers a pipeline in the GitOps repository that runs the ",(0,s.jsx)("img",{src:(0,a.Ay)("img/gitops/devops-icon.png"),style:{width:"1em"}})," / ",(0,s.jsx)("img",{src:(0,a.Ay)("img/gitops/github-icon.png"),style:{width:"1em"}})," ",(0,s.jsx)(t.a,{href:"https://github.com/XenitAB/gitops-promotion#gitops-promotion-new",children:"gitops-promotion new"})," command. It pushes a new branch and updates the ",(0,s.jsx)(t.code,{children:"dev"}),' environment manifest for the app with the new tag. It then opens an "auto-merging" pull request to integrate the new tag into the main branch.']}),"\n",(0,s.jsxs)(t.li,{children:["The ",(0,s.jsx)("img",{src:(0,a.Ay)("img/gitops/pr-icon.png"),style:{width:"1em"}})," pull request triggers another pipeline that runs ",(0,s.jsx)("img",{src:(0,a.Ay)("img/gitops/devops-icon.png"),style:{width:"1em"}})," / ",(0,s.jsx)("img",{src:(0,a.Ay)("img/gitops/github-icon.png"),style:{width:"1em"}})," ",(0,s.jsx)(t.a,{href:"https://github.com/XenitAB/gitops-promotion#gitops-promotion-new",children:"gitops-promotion status"})," command. Since ",(0,s.jsx)(t.code,{children:"dev"})," is the first environment in the list, it does nothing and reports success."]}),"\n",(0,s.jsx)(t.li,{children:"The pull request check turns green and the pull request is automatically merged by the Git provider."}),"\n",(0,s.jsxs)(t.li,{children:["The ",(0,s.jsx)("img",{src:(0,a.Ay)("img/gitops/fluxcdio-icon.png"),style:{width:"1em"}})," Flux Kustomization controller detects that there has been an update to the app's tag in the Git repository and applies this update to the Kubernetes resource for the app (typically a ",(0,s.jsx)(t.code,{children:"Deployment"}),")."]}),"\n",(0,s.jsxs)(t.li,{children:["The pods running the new container image came up healthy and so Flux sets a commit status on the ",(0,s.jsx)(t.code,{children:"main"})," branch in the GitOps repository, reporting that the update was successfully applied. This will be significant in the next section."]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"applying-to-qa",children:"Applying to qa"}),"\n",(0,s.jsx)("img",{alt:"Apply to qa",src:(0,a.Ay)("img/assets/xks/developer-guide/developer-flow-apply-qa.jpg")}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["Merging a promotion to the main branch triggers a pipeline in the GitOps repository that runs the ",(0,s.jsx)(t.a,{href:"https://github.com/XenitAB/gitops-promotion#gitops-promotion-promote",children:"gitops-promotion promote"})," command. Like ",(0,s.jsx)(t.code,{children:"new"}),", it creates a branch and updates the ",(0,s.jsx)(t.code,{children:"qa"})," environment manifest for the app with the new tag. Because the configuration for this environment says ",(0,s.jsx)(t.code,{children:"auto: true"})," it creates an auto-merging pull request."]}),"\n",(0,s.jsxs)(t.li,{children:["As before, this new pull request triggers another pipeline that runs the ",(0,s.jsx)(t.code,{children:"status"})," command. This time there is a previous environment and the status command reads the Flux commit status for that environment. Since Flux managed to apply the change in ",(0,s.jsx)(t.code,{children:"dev"})," the ",(0,s.jsx)(t.code,{children:"status"})," command reports success."]}),"\n",(0,s.jsx)(t.li,{children:"The pull request check turns green and the pull request is automatically merged by the Git provider."}),"\n",(0,s.jsxs)(t.li,{children:["The Flux Kustomization controller detects that there has been an update to the app's tag in the Git repository and applies this update to the Kubernetes resource for the app (typically a ",(0,s.jsx)(t.code,{children:"Deployment"}),")."]}),"\n",(0,s.jsxs)(t.li,{children:["In this case, someone had applied manual changes to the app's database in the ",(0,s.jsx)(t.code,{children:"dev"})," environment during development. These updates are not present in the ",(0,s.jsx)(t.code,{children:"qa"})," environment, and when the pods running the new container image come up, they cannot read state from the database and so fail their health check. Flux consequently sets a commit status on the ",(0,s.jsx)(t.code,{children:"main"})," branch of the GitHub repository, reporting that the update failed."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"Emilia's team has configured Flux to notify them when updates fail and so Emilia's chat client informs her that the update did not go through."}),"\n",(0,s.jsx)(t.h3,{id:"application-to-prod-is-blocked",children:"Application to prod is blocked"}),"\n",(0,s.jsx)("img",{alt:"Apply to prod",src:(0,a.Ay)("img/assets/xks/developer-guide/developer-flow-apply-prod-blocked.jpg")}),"\n",(0,s.jsxs)(t.p,{children:["The workflow for applying to ",(0,s.jsx)(t.code,{children:"prod"})," is similar to that of ",(0,s.jsx)(t.code,{children:"qa"})," above, but since Flux reported failure when applying the update to ",(0,s.jsx)(t.code,{children:"qa"}),", the pipeline running the ",(0,s.jsx)(t.code,{children:"status"})," command will fail and the Git provider will block merging of the pull request."]}),"\n",(0,s.jsxs)(t.p,{children:["Seeing that the rollout failed, Emilia investigates and realizes that the release is missing a database migration script. She pushes an updated release tagged ",(0,s.jsx)(t.code,{children:"cc2b7e0a"})," and so triggers the pipline running the ",(0,s.jsx)(t.code,{children:"new"})," command. Because the configuration says ",(0,s.jsx)(t.code,{children:"prflow: per-app"}),', the command "resets" the blocked pull request to apply to the updated release to the ',(0,s.jsx)(t.code,{children:"dev"})," environment."]}),"\n",(0,s.jsx)(t.h3,{id:"second-attempt-applying-to-prod",children:"Second attempt applying to prod"}),"\n",(0,s.jsx)("img",{alt:"Apply to prod",src:(0,a.Ay)("img/assets/xks/developer-guide/developer-flow-apply-prod-success.jpg")}),"\n",(0,s.jsxs)(t.p,{children:["Emilia's updated app with database migration is successfully applied, first to the ",(0,s.jsx)(t.code,{children:"dev"})," environment and then to the ",(0,s.jsx)(t.code,{children:"qa"})," environment. The ",(0,s.jsx)(t.code,{children:"status"})," check for the pull request against ",(0,s.jsx)(t.code,{children:"prod"})," turns green and the pull request can be merged. Since the configuration says ",(0,s.jsx)(t.code,{children:"auto: false"}),", the pull request is not automatically merged. Emilia can now verify the update in the ",(0,s.jsx)(t.code,{children:"qa"})," environment and then merge the pull request through the Git provider's user interface."]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453(e,t,i){i.d(t,{R:()=>a,x:()=>r});var n=i(6540);const s={},o=n.createContext(s);function a(e){const t=n.useContext(o);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);