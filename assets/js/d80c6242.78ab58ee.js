"use strict";(globalThis.webpackChunkhome=globalThis.webpackChunkhome||[]).push([[9774],{8453(e,n,t){t.d(n,{R:()=>s,x:()=>r});var i=t(6540);const o={},a=i.createContext(o);function s(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(a.Provider,{value:n},e.children)}},9333(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"xks/developer-guide/container-security","title":"Container Security","description":"Container security is a critical component of the framework. Kubernetes in its vanilla form is by design open, but that also means that to a certain extent Kuberentes is insecure. In a multi-tenant context this statement holds even more truth. Container security in Kubernetes can be seen from two different perspectives. One is protecting the cluster from being exploited by maliciously configured Pods. The other is mitigating the attack surface of an application in a cluster. Sometimes these two perspectives are one and the same. XKF tries to balance between enforcing good security practices by default while allowing for developer flexibility. For this reason some security measures are required while others are merely recommendations to help developers achieve a higher security standard.","source":"@site/docs/xks/developer-guide/container-security.md","sourceDirName":"xks/developer-guide","slug":"/xks/developer-guide/container-security","permalink":"/docs/xks/developer-guide/container-security","draft":false,"unlisted":false,"editUrl":"https://github.com/xenitab/xenitab.github.io/edit/main/docs/xks/developer-guide/container-security.md","tags":[],"version":"current","frontMatter":{"id":"container-security","title":"Container Security"},"sidebar":"docs","previous":{"title":"Cloud IAM","permalink":"/docs/xks/developer-guide/cloud-iam"},"next":{"title":"Continuous Integration","permalink":"/docs/xks/developer-guide/ci-cd/ci"}}');var o=t(4848),a=t(8453);const s={id:"container-security",title:"Container Security"},r=void 0,l={},c=[{value:"Default Security Context",id:"default-security-context",level:2},{value:"Read Only Root Filesystem",id:"read-only-root-filesystem",level:3},{value:"Allow Privilege Escalation",id:"allow-privilege-escalation",level:3},{value:"Dropped Capabilities",id:"dropped-capabilities",level:3},{value:"Pod Constraints",id:"pod-constraints",level:2},{value:"Host Namespaces",id:"host-namespaces",level:3},{value:"Host Networking",id:"host-networking",level:3},{value:"Privileged Containers",id:"privileged-containers",level:3},{value:"Capabilities",id:"capabilities",level:3},{value:"Proc Mount",id:"proc-mount",level:3},{value:"Volume Type",id:"volume-type",level:3},{value:"Flex Volumes",id:"flex-volumes",level:3},{value:"Non Root User",id:"non-root-user",level:2},{value:"Seccomp",id:"seccomp",level:2},{value:"Automount ServiceAccount Token",id:"automount-serviceaccount-token",level:2},{value:"Vulnerability Reports",id:"vulnerability-reports",level:2},{value:"Pod max PID",id:"pod-max-pid",level:2}];function d(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.p,{children:"Container security is a critical component of the framework. Kubernetes in its vanilla form is by design open, but that also means that to a certain extent Kuberentes is insecure. In a multi-tenant context this statement holds even more truth. Container security in Kubernetes can be seen from two different perspectives. One is protecting the cluster from being exploited by maliciously configured Pods. The other is mitigating the attack surface of an application in a cluster. Sometimes these two perspectives are one and the same. XKF tries to balance between enforcing good security practices by default while allowing for developer flexibility. For this reason some security measures are required while others are merely recommendations to help developers achieve a higher security standard."}),"\n",(0,o.jsx)(n.h2,{id:"default-security-context",children:"Default Security Context"}),"\n",(0,o.jsx)(n.p,{children:"All Pods in the cluster will have a default security context enforced. Any default security context setting which has not been configured properly when applying the Pod to the cluster will be automatically set before the Pod is created. No action has to be taken from the end user but it is important to be aware that the Pod applied may not be identical to the Pod created and what these settings mean."}),"\n",(0,o.jsx)(n.p,{children:"The Pod below is the most basic yet valid Pod which can be applied to a Kubernetes."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Pod\nmetadata:\n  name: app\nspec:\n  containers:\n    - name: app\n      image: busybox:1.35.0\n"})}),"\n",(0,o.jsx)(n.p,{children:"When applied to an XKF Kubernetes cluster the following mutations occur."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Pod\nmetadata:\n  name: app\nspec:\n  automountServiceAccountToken: false\n  containers:\n    - name: app\n      image: busybox:1.35.0\n      securityContext:\n        readOnlyRootFilesystem: true\n        allowPrivilegeEscalation: false\n        capabilities:\n          drop:\n            - NET_RAW\n            - CAP_SYS\n  securityContext:\n    seccompProfile:\n      type: RuntimeDefault\n"})}),"\n",(0,o.jsx)(n.h3,{id:"read-only-root-filesystem",children:"Read Only Root Filesystem"}),"\n",(0,o.jsx)(n.p,{children:"This setting is the one that may have the largest impact on a deployed application if it is expected to write to the file system. Containers may be ephemeral but that does not mean that certain applications may still want to write temporary files. Enabling read only root filesystem blocks the container from writing to its filesystem by default. The reasoning for this is that if an attacker is able to gain access to a container the attacker will not be able to modify any files or add any additional binaries to the container."}),"\n",(0,o.jsxs)(n.p,{children:["Of course there is a solution for applications that still do want to write to the filesystem. The solution is to create an ",(0,o.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/storage/volumes/#emptydir",children:(0,o.jsx)(n.code,{children:"emptyDir"})})," volume and mount it to the directory to which files should be written. In the example below the ",(0,o.jsx)(n.code,{children:"emptyDir"})," volume ",(0,o.jsx)(n.code,{children:"tmp"})," is mounted to the path ",(0,o.jsx)(n.code,{children:"/tmp"})," making it possible to write files to the directory."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Pod\nmetadata:\n  name: app\nspec:\n  containers:\n    - name: app\n      image: busybox:1.35.0\n      securityContext:\n        readOnlyRootFilesystem: true\n        allowPrivilegeEscalation: false\n        capabilities:\n          drop:\n            - NET_RAW\n            - CAP_SYS_ADMIN\n      volumeMounts:\n        - mountPath: /tmp\n          name: tmp\n  volumes:\n    - emptyDir: {}\n      name: tmp\n"})}),"\n",(0,o.jsx)(n.h3,{id:"allow-privilege-escalation",children:"Allow Privilege Escalation"}),"\n",(0,o.jsx)(n.p,{children:"Disabling privilege escalation for all Pods is critical for applications to not gain greater access to the Node than they need to. This setting will probably never affect most applications."}),"\n",(0,o.jsx)(n.h3,{id:"dropped-capabilities",children:"Dropped Capabilities"}),"\n",(0,o.jsx)(n.p,{children:"Linux capabilities are certain root permissions that can be given to containers without giving root access. Certain capabilities should never be given to a container as they would give too much access, for this reason they are always dropped."}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"CAP_SYS_ADMIN"})," - Is the same as making the container root, as it would allow a container to escalate privileges."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"NET_RAW"})," - Allows a container to craft raw network packets which can be exploited for malicious actions."]}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"pod-constraints",children:"Pod Constraints"}),"\n",(0,o.jsx)(n.p,{children:"In addition to the default security context there are certain configuration settings which are not allowed in XKF. They have a lower impact on end users as they are opted into, but they are good to be aware of and can explain why a Pods creation may be blocked by the cluster. The enforcement is done before the Pod is created, this means that a Deployment may be allowed to be created but the Pods that result will not, causing a Deployment to always have zero replicas."}),"\n",(0,o.jsx)(n.h3,{id:"host-namespaces",children:"Host Namespaces"}),"\n",(0,o.jsxs)(n.p,{children:["Being able to share process IDs or memory between a container and a host means that the container would in theory have access to the host or any containers also running on the host. Setting ",(0,o.jsx)(n.code,{children:"hostPID"})," or ",(0,o.jsx)(n.code,{children:"hostIPC"})," to ",(0,o.jsx)(n.code,{children:"true"})," would allow for this to happen. For this reason that is not allowed."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Pod\nmetadata:\n  name: app\nspec:\n  hostPID: true\n  hostIPC: true\n"})}),"\n",(0,o.jsx)(n.h3,{id:"host-networking",children:"Host Networking"}),"\n",(0,o.jsx)(n.p,{children:"Allowing a Pod access to the host network namespace would mean giving it access to the hosts loopback device and enable it to listen to the network traffic of all Pods on the host."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Pod\nmetadata:\n  name: app\nspec:\n  hostNetwork: true\n"})}),"\n",(0,o.jsx)(n.p,{children:"Using a host port for a Pod's container will result in binding that hosts port to the container port. This would expose the container to the network outside of the cluster. This can cause issues in cases where the ports have to be unique, and is generally a feature that is not needed in XKF, which is why it is not allowed."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Pod\nmetadata:\n  name: app\nspec:\n  containers:\n    - ports:\n        - hostPort: 10902\n"})}),"\n",(0,o.jsx)(n.h3,{id:"privileged-containers",children:"Privileged Containers"}),"\n",(0,o.jsx)(n.p,{children:"Privileged containers have root capabilities on the host machine and are therefore not allowed in XKF. There would be no separation between the container and the host if this setting were to be allowed."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Pod\nmetadata:\n  name: app\nspec:\n  containers:\n    - securityContext:\n        privileged: true\n"})}),"\n",(0,o.jsx)(n.h3,{id:"capabilities",children:"Capabilities"}),"\n",(0,o.jsx)(n.p,{children:"As stated in the default security context section certain capabilities will always be dropped. It is however also possible to grant capabilities to a Pod. Therefore any Pods that attempt to add extra capabilities are not allowed, as it could lead to privilege escalation."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Pod\nmetadata:\n  name: app\nspec:\n  containers:\n    - securityContext:\n        capabilities:\n          add:\n            - NEW_RAW\n"})}),"\n",(0,o.jsx)(n.h3,{id:"proc-mount",children:"Proc Mount"}),"\n",(0,o.jsxs)(n.p,{children:["There are certain files in the ",(0,o.jsx)(n.code,{children:"/proc"})," directory that may be sensitive if exposed to a container. By default the container runtime will apply a filter to the files mounted to the container from the directory, so opting out of it is not allowed."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Pod\nmetadata:\n  name: app\nspec:\n  containers:\n    - securityContext:\n        procMount: UnmaskedProcMount\n"})}),"\n",(0,o.jsx)(n.h3,{id:"volume-type",children:"Volume Type"}),"\n",(0,o.jsxs)(n.p,{children:["The types of volumes are limited to a known set to mitigate host path mounting and the use of unknown volume types. The allowed volume types cover the majority of use cases. The following volume types are currently allowed in XKF, ",(0,o.jsx)(n.code,{children:"configMap"}),", ",(0,o.jsx)(n.code,{children:"downwardAPI"}),", ",(0,o.jsx)(n.code,{children:"emptyDir"}),", ",(0,o.jsx)(n.code,{children:"persistentVolumeClaim"}),", ",(0,o.jsx)(n.code,{children:"secret"}),", ",(0,o.jsx)(n.code,{children:"projected"}),", ",(0,o.jsx)(n.code,{children:"csi"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["As stated before blocking any ",(0,o.jsx)(n.code,{children:"hostPath"})," volumes is critical as mounting certain directories or files on the host would give a container insight to or control over the host."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Pod\nmetadata:\n  name: app\nspec:\n  volumes:\n    - hostPath:\n        path: /proc\n"})}),"\n",(0,o.jsx)(n.h3,{id:"flex-volumes",children:"Flex Volumes"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.a,{href:"https://kubernetes.io/docs/concepts/storage/volumes/#flexvolume",children:"Flex Volumes"})," are a deprecated type of volume that are no longer maintained in the Kubernetes project. Flex volume drives are not installed in XKF clusters but are still not allowed to be used."]}),"\n",(0,o.jsx)(n.h2,{id:"non-root-user",children:"Non Root User"}),"\n",(0,o.jsxs)(n.p,{children:["A common practice for a lot of images is to, by default, run the containers as the user root. It is widespread because it is the deafault in a lot of the base images, but it does not mean that it is the best choice. Running the container as root is generally not a problem as it is not the same as root on the node. It does however become a problem when new container runtime vulnerabilities are found which allow escaping the sandbox. An example of such a vulnerability is ",(0,o.jsx)(n.a,{href:"https://avd.aquasec.com/nvd/2019/cve-2019-5736/",children:"CVE-2019-5736"})," which allowed containers running as root users to escalate its privileges to becoming root on the node. A mitigation for this vulnerability would have been to make sure that the container is running as user other than root. With the knowledge that the mitigation for future container vulnerabilities is so simple it would be lazy not to take the precautionary steps."]}),"\n",(0,o.jsxs)(n.p,{children:["Changing the user has to be solved both at the source of the image and in Kubernetes to ensure no issues appear. A common problem is that the new non root user does not have the correct permissions for required files and directories.\nA general recommendation is also to use a user ID (UID) and group ID (GID) greater than ",(0,o.jsx)(n.code,{children:"10000"})," to avoid overlapping with other system users."]}),"\n",(0,o.jsx)(n.p,{children:"Create a Dockerfile which changes the UID and GID from the default of the base image."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-Dockerfile",children:"FROM alpine:latest\nRUN addgroup -g 10000 app && adduser -u 10000 -G app -D app\nUSER 10000\n\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Configure the Pod that that is runs with a non root user. The field ",(0,o.jsx)(n.code,{children:"runAsUser"})," has to be configured when ",(0,o.jsx)(n.code,{children:"runAsNonRoot"})," is set to ",(0,o.jsx)(n.code,{children:"true"}),". Set both these values to be the UID and GID configured in the Dockerfile."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Pod\nmetadata:\n  name: app\nspec:\n  securityContext:\n    runAsNonRoot: true\n    runAsUser: 10000\n    runAsGroup: 10000\n"})}),"\n",(0,o.jsxs)(n.p,{children:["In the future enforcement of running as a non root users will be handled by XKF. When this is enabled a containers attempting to run with the UID 0 will not be permitted. The minimum UID and GID will also be enforced to ",(0,o.jsx)(n.code,{children:"10000"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"seccomp",children:"Seccomp"}),"\n",(0,o.jsxs)(n.p,{children:["Secure computing mode (",(0,o.jsx)(n.a,{href:"https://docs.docker.com/engine/security/seccomp/",children:"seccomp"}),") is a pod wide securityContext setting and is a way to restrict which system calls a application can make inside a container."]}),"\n",(0,o.jsxs)(n.p,{children:["XKF is configured to mutate all Pods, which do not specify a seccomp profile, with the profiler ",(0,o.jsx)(n.code,{children:"RuntimeDefault"}),".\nThis is a security measure to give you as a developer a good base to stand-on while minimizing the risk of getting issues in your application."]}),"\n",(0,o.jsxs)(n.p,{children:["It is possible to use a different profile if the application for some reason does not work as intended with the ",(0,o.jsx)(n.code,{children:"RuntimeDefault"}),"profile. To allow all system calls the application can use the profile ",(0,o.jsx)(n.code,{children:"Unconfined"}),". The Pod will not be mutated as long as a seccomp profile has been set in the security context."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-.yaml",children:'apiVersion: v1\nkind: Pod\nmetadata:\n  name: test\nspec:\n  securityContext:\n    seccompProfile:\n      type: Unconfined\n  containers:\n    - command:\n        - /bin/sh\n      resources:\n        requests:\n          memory: "16Mi"\n          cpu: "10m"\n        limits:\n          memory: "64Mi"\n          cpu: "100m"\n      image: alpine:latest\n      name: container-00\n      tty: true\n'})}),"\n",(0,o.jsxs)(n.p,{children:["To see which system calls is disabled in ",(0,o.jsx)(n.code,{children:"RuntimeDefault"})," the most human readable option we have found is ",(0,o.jsx)(n.a,{href:"https://docs.docker.com/engine/security/seccomp/#significant-syscalls-blocked-by-the-default-profile",children:"dockers profile page"}),".\nAnother option is to read the containerd ",(0,o.jsx)(n.a,{href:"https://github.com/containerd/containerd/blob/v1.6.1/contrib/seccomp/seccomp_default.go",children:"code"}),", they might not be identical but it's close enough."]}),"\n",(0,o.jsxs)(n.p,{children:["RuntimeDefault isn't a ideal solution and in the long run we hope to add support to something like ",(0,o.jsx)(n.a,{href:"https://github.com/kubernetes-sigs/security-profiles-operator",children:"security-profile-operator"})," to XKF."]}),"\n",(0,o.jsx)(n.h2,{id:"automount-serviceaccount-token",children:"Automount ServiceAccount Token"}),"\n",(0,o.jsx)(n.p,{children:"By default all pods uses the default serviceAccount. The pod will also automatically get the default serviceAccounts Kubernetes token.\nMost application workloads don't have a need for this token."}),"\n",(0,o.jsxs)(n.p,{children:["XKF is configured to mutate all Pods, which do not specify explicitly ",(0,o.jsx)(n.code,{children:"spec.automountServiceAccountToken"})," and will set the value to ",(0,o.jsx)(n.code,{children:"false"})," by default."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Pod\nmetadata:\n  name: app\nspec:\n  automountServiceAccountToken: false\n  containers:\n    - name: app\n      image: busybox:1.35.0\n"})}),"\n",(0,o.jsx)(n.h2,{id:"vulnerability-reports",children:"Vulnerability Reports"}),"\n",(0,o.jsxs)(n.p,{children:["Containers can use the same image for a very long time, either because the application has not been updated for a long time, or because an external image is used and not updated as new versions are released. These old image versions may collect security vulnerabilities as new ones are discovered and patched in later releases, but it does not mean that an image is insecure just because an image version is old. XKF helps developers detect security vulnerabilities in container images with the help of ",(0,o.jsx)(n.a,{href:"https://github.com/aquasecurity/starboard/",children:"Starboard"}),". One thing Starboard does is to continuously scan images used in the cluster with the help of ",(0,o.jsx)(n.a,{href:"https://github.com/aquasecurity/trivy/",children:"Trivy"}),". Any vulnerability found will be stored as a resource in the Namespace in which it was found in."]}),"\n",(0,o.jsx)(n.p,{children:"View all the vulnerability reports that exists in the current namespace."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell",children:"kubectl get vulnerabilityreports\n"})}),"\n",(0,o.jsx)(n.p,{children:"Describe a specific vulnerability report to view specific details."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-shell",children:"kubectl describe vulnerabilityreports.aquasecurity.github.io <report-name>\n"})}),"\n",(0,o.jsx)(n.p,{children:"Below is an example of how the output may look. It includes information of the scanner used, when the scan was run, and the vulnerabilities found. Each vulnerability has a CVE ID and a link for more information about the vulnerability."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-yaml",children:"Report:\n  Scanner:\n    Name:     Trivy\n    Vendor:   Aqua Security\n    Version:  0.24.3\n  Summary:\n    Critical Count:  0\n    High Count:      3\n    Low Count:       0\n    Medium Count:    1\n    Unknown Count:   0\n  Update Timestamp:  2022-04-04T08:49:01Z\n  Vulnerabilities:\n    Fixed Version:      1.1.1n-r0\n    Installed Version:  1.1.1l-r0\n    Links:\n    Primary Link:       https://avd.aquasec.com/nvd/cve-2022-0778\n    Resource:           libcrypto1.1\n    Score:              7.5\n    Severity:           HIGH\n    Title:              openssl: Infinite loop in BN_mod_sqrt() reachable when parsing certificates\n    Vulnerability ID:   CVE-2022-0778\n    Fixed Version:      3.3.3p1-r3\n    Installed Version:  3.3.3p1-r2\n    Links:\n    Primary Link:       https://avd.aquasec.com/nvd/cve-2022-0778\n    Resource:           libretls\n    Score:              7.5\n    Severity:           HIGH\n    Title:              openssl: Infinite loop in BN_mod_sqrt() reachable when parsing certificates\n    Vulnerability ID:   CVE-2022-0778\n    Fixed Version:      1.1.1n-r0\n    Installed Version:  1.1.1l-r0\n    Links:\n    Primary Link:       https://avd.aquasec.com/nvd/cve-2022-0778\n    Resource:           libssl1.1\n    Score:              7.5\n    Severity:           HIGH\n    Title:              openssl: Infinite loop in BN_mod_sqrt() reachable when parsing certificates\n    Vulnerability ID:   CVE-2022-0778\n    Fixed Version:      1.2.12-r0\n    Installed Version:  1.2.11-r3\n    Links:\n    Primary Link:      https://avd.aquasec.com/nvd/cve-2018-25032\n    Resource:          zlib\n    Score:             4.4\n    Severity:          MEDIUM\n    Title:             zlib: A flaw in zlib-1.2.11 when compressing (not decompressing!) certain inputs.\n    Vulnerability ID:  CVE-2018-25032\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The presence of a vulnerability does not mean that a patched version exists yet, or even that the image is inherently insecure. The vulnerability may affect components that are not used or have low risk to being exposed. It is however important to be conscious of the vulnerabilities that exist and consider future work to take responsibility for fixing them. Refer to the ",(0,o.jsx)(n.a,{href:"https://aquasecurity.github.io/starboard/latest/faq",children:"official Starboard documentation"})," for more specific documentation."]}),"\n",(0,o.jsx)(n.h2,{id:"pod-max-pid",children:"Pod max PID"}),"\n",(0,o.jsxs)(n.p,{children:["XKF has set a maximum limit on how many PIDs a single Pod can utilize. This is to make sure that a Pod can't cause ",(0,o.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Starvation_(computer_science)",children:"PID starvation"})," for other Pods by consuming all available PIDs on the host OS."]}),"\n",(0,o.jsxs)(n.p,{children:["The max value today is ",(0,o.jsx)(n.a,{href:"https://github.com/XenitAB/terraform-modules/blob/a0679d05b4509aaac115bc282c1e289bad166991/modules/azure/aks/aks.tf#L90-L92",children:"1000"}),".\nConfiguration changes on cluster level have to be made in the case where a Pod requires more than 1000 PIDs."]})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}}}]);