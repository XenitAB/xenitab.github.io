"use strict";(globalThis.webpackChunkhome=globalThis.webpackChunkhome||[]).push([[1196],{1330(e,n,t){t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"xks/developer-guide/cloud-iam","title":"Cloud IAM","description":"Sometimes applications will need to integrate with other cloud resources as they require things like persistent data storage. When working with XKS each namespace is accompanied by an Azure resource","source":"@site/docs/xks/developer-guide/cloud-iam.md","sourceDirName":"xks/developer-guide","slug":"/xks/developer-guide/cloud-iam","permalink":"/docs/xks/developer-guide/cloud-iam","draft":false,"unlisted":false,"editUrl":"https://github.com/xenitab/xenitab.github.io/edit/main/docs/xks/developer-guide/cloud-iam.md","tags":[],"version":"current","frontMatter":{"id":"cloud-iam","title":"Cloud IAM"},"sidebar":"docs","previous":{"title":"Secrets Management","permalink":"/docs/xks/developer-guide/secrets-management"},"next":{"title":"Container Security","permalink":"/docs/xks/developer-guide/container-security"}}');var a=t(4848),s=t(8453);const r={id:"cloud-iam",title:"Cloud IAM"},o=void 0,c={},d=[{value:"Cloud Providers",id:"cloud-providers",level:2},{value:"Azure",id:"azure",level:3},{value:"SDK",id:"sdk",level:4},{value:"Limiting Permissions",id:"limiting-permissions",level:4},{value:"AWS",id:"aws",level:3},{value:"SDK",id:"sdk-1",level:4}];function l(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.p,{children:"Sometimes applications will need to integrate with other cloud resources as they require things like persistent data storage. When working with XKS each namespace is accompanied by an Azure resource\ngroup or an AWS account. This is where cloud resources can be created by each tenant. To keep things simple it may be a good idea to not share these resources across multiple tenants, as one of the\ntenants has to own each resource. Instead look at other options like exposing an API inside the cluster instead. As one may expect the authentication methods differ when running XKS in Azure and AWS,\nthis is because the APIs and underlying authentication methods differ greatly. It is important to take this into consideration when reading this documentation."}),"\n",(0,a.jsx)(n.h2,{id:"cloud-providers",children:"Cloud Providers"}),"\n",(0,a.jsx)(n.h3,{id:"azure",children:"Azure"}),"\n",(0,a.jsxs)(n.p,{children:["The recommended way to authenticate towards Azure in XKS is to make use of ",(0,a.jsx)(n.a,{href:"https://github.com/Azure/aad-pod-identity",children:"AAD Pod Identity"})," which runs inside the cluster. AAD Pod Identity allows Pods\nwithin the cluster to use ",(0,a.jsx)(n.a,{href:"https://docs.microsoft.com/en-us/azure/active-directory/managed-identities-azure-resources/overview",children:"managed identities"})," to authenticate towards Azure. This removes the need\nfor static credentials that have to be passed to the Pods. It works by intercepting API requests before they leave the cluster and will attach the correct credential based on the source Pod of the\nrequest."]}),"\n",(0,a.jsxs)(n.p,{children:["Each tenant namespace comes preconfigured with an ",(0,a.jsx)(n.a,{href:"https://azure.github.io/aad-pod-identity/docs/concepts/azureidentity/",children:"AzureIdentity"})," and\n",(0,a.jsx)(n.a,{href:"https://azure.github.io/aad-pod-identity/docs/concepts/azureidentitybinding/",children:"AzureIdentityBinding"}),". These have been setup so that the identity has access to the tenant's resource group. All that has\nto be done to enable the managed identity is to add the label ",(0,a.jsx)(n.code,{children:"foo"})," to the Pod. The preconfigured AzureIdentity has a labelselector which expects the label to have the same value as the namespace\nname."]}),"\n",(0,a.jsx)(n.p,{children:"This example will deploy a Pod with the Azure CLI so that you can test access to the Azure API."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: Pod\nmetadata:\n  name: msi-test\n  namespace: tenant\n  labels:\n    aadpodidbinding: ${NAMESPACE_NAME}\nspec:\n  containers:\n    - name: msi-test\n      image: mcr.microsoft.com/azure-cli\n      tty: true\n      volumeMounts:\n        - name: az-cli\n          mountPath: /root/.azure\n  volumes:\n    - name: az-cli\n      emptyDir: {}\n"})}),"\n",(0,a.jsx)(n.p,{children:"After the Pod has started you can execute a shell in the Pod and verify that the managed identity is working."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"kubectl -n tenant exec -it msi-test\naz login --identity\naz account show\n"})}),"\n",(0,a.jsxs)(n.p,{children:["Make sure your application supports retries when retrieving tokens. It should at least be able to retry for 60 seconds. Read more about ",(0,a.jsx)(n.a,{href:"https://azure.github.io/aad-pod-identity/docs/best-practices/#retry-on-token-retrieval",children:"token retrieval retry best practices"}),". More good practices can be found in the ",(0,a.jsx)(n.a,{href:"https://azure.github.io/aad-pod-identity/docs/best-practices",children:"aad-pod-identity docs"}),"."]}),"\n",(0,a.jsx)(n.h4,{id:"sdk",children:"SDK"}),"\n",(0,a.jsx)(n.p,{children:"A common scenario is that an application may need API access to Azure resources through the API. In these cases the best solution is to use the language specific SDKs which will most of the time\nsupport MSI credentials. Below are examples for how to create a client using MSI credentials which can interact with Azure storage account blobs."}),"\n",(0,a.jsx)(n.p,{children:"** Golang **"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n\t"time"\n\n  "github.com/Azure/go-autorest/autorest/azure/auth"\n\tblob "github.com/Azure/azure-storage-blob-go/azblob"\n)\n\nfunc main() {\n  msiConfig := auth.NewMSIConfig()\n\n  spt, err := msiConfig.ServicePrincipalToken()\n  if err != nil {\n    return nil, err\n  }\n  if err := spt.Refresh(); err != nil {\n    return nil, err\n  }\n\n  tc, err := blob.NewTokenCredential(spt.Token().AccessToken, func(tc blob.TokenCredential) time.Duration {\n    err := spt.Refresh()\n    if err != nil {\n      return 30 * time.Second\n    }\n    tc.SetToken(spt.Token().AccessToken)\n    return spt.Token().Expires().Sub(time.Now().Add(2 * time.Minute))\n  }), nil\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"** C# with ASP.NET **"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-aspnet",children:'using Azure;\nusing Azure.Identity;\nusing Azure.Storage.Blobs;\n\nasync static Task CreateBlockBlobAsync(string accountName, string containerName, string blobName)\n{\n    string containerEndpoint = string.Format("https://{0}.blob.core.windows.net/{1}",\n                                                accountName,\n                                                containerName);\n    BlobContainerClient containerClient = new BlobContainerClient(new Uri(containerEndpoint),\n                                                                    new DefaultAzureCredential());\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"limiting-permissions",children:"Limiting Permissions"}),"\n",(0,a.jsx)(n.p,{children:"TBD"}),"\n",(0,a.jsx)(n.h3,{id:"aws",children:"AWS"}),"\n",(0,a.jsxs)(n.p,{children:["When authenticating towards AWS in XKS we recommend using ",(0,a.jsx)(n.a,{href:"https://docs.aws.amazon.com/emr/latest/EMR-on-EKS-DevelopmentGuide/setting-up-enable-IAM.html",children:"IAM Roles for Service Accounts"})," (IRSA). IRSA\nworks by intercepting AWS API calls before leaving the cluster and appending the correct authentication token to the request. This removes the need for static security credentials as it is handled\noutside the app. IRSA works by annotating a Service Account with a reference to a specfic AWS IAM role. When that Service Account is attached to a Pod, the Pod will be able to assume the IAM role.\nThe reason IRSA works in a multi-tenant cluster is because the reference is multi-directional. The Service Account has to specify the full role ARN it wants to assume and the IAM role has to specify\nthe name and namespace of the Service Account which is allowed to assume the role. So it is not enough to know the ARN of the role unless you have access to the correct namespace and Service Account."]}),"\n",(0,a.jsx)(n.p,{children:"Start by defining a variable for the OIDC URLs that should be trusted. Currently this is a static definition that needs to be specified but work is planned to make this value discoverable in the\nfuture."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'variable "oidc_urls" {\n  description = "List of EKS OIDC URLs to trust."\n  type        = list(string)\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"A new OIDC provider has to be created for each trusted URL. The simplest way to do this is to iterate the URL list. This should only be done once per tenant account, so try to define all roles in the\nsame Terraform state."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'data "tls_certificate" "this" {\n  for_each = {\n    for v in var.oidc_urls :\n    v => v\n  }\n  url = each.value\n}\n\nresource "aws_iam_openid_connect_provider" "this" {\n  for_each = {\n    for v in var.oidc_urls :\n    v => v\n  }\n  client_id_list  = ["sts.amazonaws.com"]\n  thumbprint_list = [data.tls_certificate.this[each.value].certificates[0].sha1_fingerprint]\n  url             = each.value\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["Define an AWS IAM policy document and an instance of the ",(0,a.jsx)(n.a,{href:"https://github.com/XenitAB/terraform-modules/tree/main/modules/aws/irsa",children:"IRSA Terraform module"}),". The policy document describes which\npermissions should be granted to a Pod and the IRSA module creates the IAM policy and role for a Service Account in a specific namespace. The example below will for example only work with a Service\nAccount called ",(0,a.jsx)(n.code,{children:"irsa-test"})," in the namespace ",(0,a.jsx)(n.code,{children:"tenant"}),". Keep in mind that a policy document and module instance is required for each unique permission set."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'data "aws_iam_policy_document" "get_login_profile" {\n  statement {\n    effect = "Allow"\n    actions = [\n      "iam:GetLoginProfile",\n    ]\n    resources = ["*"]\n  }\n}\n\nmodule "irsa_test" {\n  source = "github.com/xenitab/terraform-modules//modules/aws/irsa?ref=2021.08.9"\n\n  name = "irsa-test"\n  oidc_providers = [\n    for v in var.oidc_urls :\n    {\n      url = v\n      arn = aws_iam_openid_connect_provider.this[v].arn\n    }\n  ]\n  kubernetes_namespace       = "tenant"\n  kubernetes_service_account = "irsa-test"\n  policy_json                = data.aws_iam_policy_document.get_login_profile.json\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"It is a good idea to output the ARN of the created role, as it will be needed in the next step."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-hcl",children:'output "irsa_test_arn" {\n  value = module.irsa_test.role_arn\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The correct IAM roles and policies should be created after the Terraform has been applied. The next step is to create a Service Account with the same name as specified in the IRSA module and annotate it\nwith the key ",(0,a.jsx)(n.code,{children:"eks.amazonaws.com/role-arn"}),". The value should be the full ARN of the created IAM role. Note that the account id is part of the ARN as the IAM role is created in a different account\nthan the one the cluster is located in."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:"apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: irsa-test\n  namespace: tenant\n  annotations:\n    eks.amazonaws.com/role-arn: arn:aws:iam::111111111111:role/irsa-test\n"})}),"\n",(0,a.jsx)(n.p,{children:"Create a Pod using the newly created Service Account to test using the IAM role."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-yaml",children:'apiVersion: v1\nkind: Pod\nmetadata:\n  name: irsa-test\n  namespace: tenant\nspec:\n  serviceAccountName: irsa-test\n  containers:\n  - name: irsa-test\n      image: amazon/aws-cli\n      command: ["sh"]\n      stdin: true\n      tty: true\n'})}),"\n",(0,a.jsx)(n.p,{children:"After the Pod has started you can execute a shell in the Pod and verify that the managed identity is working."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-bash",children:"kubectl -n tenant exec -it irsa-test\naws sts get-caller-identity\n"})}),"\n",(0,a.jsx)(n.h4,{id:"sdk-1",children:"SDK"}),"\n",(0,a.jsx)(n.p,{children:"TBD"})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453(e,n,t){t.d(n,{R:()=>r,x:()=>o});var i=t(6540);const a={},s=i.createContext(a);function r(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);