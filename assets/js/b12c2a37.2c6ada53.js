"use strict";(globalThis.webpackChunkhome=globalThis.webpackChunkhome||[]).push([[4128],{8453(e,t,n){n.d(t,{R:()=>o,x:()=>i});var s=n(6540);const a={},r=s.createContext(a);function o(e){const t=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(r.Provider,{value:t},e.children)}},9154(e,t,n){n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"xks/developer-guide/secrets-management","title":"Secrets Management","description":"Secrets management is an important feature when building secure products. Access to secrets should be limited, and it should be easy to rotate them when required. It becomes a requirement when working with","source":"@site/docs/xks/developer-guide/secrets-management.md","sourceDirName":"xks/developer-guide","slug":"/xks/developer-guide/secrets-management","permalink":"/docs/xks/developer-guide/secrets-management","draft":false,"unlisted":false,"editUrl":"https://github.com/xenitab/xenitab.github.io/edit/main/docs/xks/developer-guide/secrets-management.md","tags":[],"version":"current","frontMatter":{"id":"secrets-management","title":"Secrets Management"},"sidebar":"docs","previous":{"title":"API migrations","permalink":"/docs/xks/developer-guide/api-migrations"},"next":{"title":"Cloud IAM","permalink":"/docs/xks/developer-guide/cloud-iam"}}');var a=n(4848),r=n(8453);const o={id:"secrets-management",title:"Secrets Management"},i=void 0,c={},l=[{value:"Auto updating secrets",id:"auto-updating-secrets",level:2},{value:"Cloud Providers",id:"cloud-providers",level:2},{value:"Azure",id:"azure",level:3},{value:"AWS",id:"aws",level:3},{value:"Automatic Reloading",id:"automatic-reloading",level:2},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Did you forget to declare the <code>SecretProviderClass</code>?",id:"did-you-forget-to-declare-the-secretproviderclass",level:3},{value:"Verifying your loaded YAML",id:"verifying-your-loaded-yaml",level:3},{value:"Is your key vault correctly configured, and does the pod have access to it?",id:"is-your-key-vault-correctly-configured-and-does-the-pod-have-access-to-it",level:3},{value:"Are your environment variables correctly set?",id:"are-your-environment-variables-correctly-set",level:3},{value:"Are your secret names matching the names in the reloader statement?",id:"are-your-secret-names-matching-the-names-in-the-reloader-statement",level:3}];function d(e){const t={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["Secrets management is an important feature when building secure products. Access to secrets should be limited, and it should be easy to rotate them when required. It becomes a requirement when working with\nGitOps as secrets can and should not be committed to a git repository. This means that secrets have to be loaded from another source separate from the manifests, but before the application is started.\nTo solve this problem XKS makes use of the ",(0,a.jsx)(t.a,{href:"https://secrets-store-csi-driver.sigs.k8s.io/providers.html",children:"Secret Store CSI Driver"})," project when running in both Azure and AWS. The CSI driver creates an\nentrypoint so that secrets store services in cloud providers can be read as Kubernetes volumes. The project works in a similar way in both Azure and AWS but there are some configuration differences\nas the service that stores the secrets is different."]}),"\n",(0,a.jsx)(t.p,{children:"A common question when looking at the CSI Driver is why not just load the secret with the help of the cloud provider's SDK? While that solution may work it is not recommended as it creates a close\ncoupling between the application logic and the secret source. A simple thing such as renaming the secret could require the application to be compiled again. Local development could also be affected as\nthe application would need alternative logic get the secrets locally. With the CSI Driver the application can just expect the secrets to be read through a file or environment variable, the\nmethod in which that file or environment variable got created is irrelevant for the application."}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:["The guide below assumes that you have read and understood the ",(0,a.jsx)(t.a,{href:"/docs/xks/developer-guide/cloud-iam",children:"Cloud IAM"})," documentation as the Pod loading the secret will need to have permission to read the secret."]}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["The main component of the Secret Store CSI Driver is the Secret Provider Class. The Secret Provider Class creates the link between a remote secret and a Kubernetes volume. It can be referenced as a\nvolume which can be mounted in a Pod, it can additionally be configured to be written to a Kubernetes Secret. The name of the Secret Provider Class is only used as a reference when creating a module.\nThe ",(0,a.jsx)(t.code,{children:"objects"})," field contains a list of references to the secret in the secret store. The object name is the name of the secret in for example Azure KeyVault or AWS Secrets Manager."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:'apiVersion: secrets-store.csi.x-k8s.io/v1\nkind: SecretProviderClass\nmetadata:\n  name: foo\nspec:\n  provider: <provider>\n  parameters:\n    objects: |\n      - objectName: "bar"\n        objectType: "<type>"\n      - objectName: "baz"\n        objectType: "<type>"\n'})}),"\n",(0,a.jsxs)(t.p,{children:["When mounting the Secret Provider Class to a Pod a file will be created with the contents of the secret. The file name will either be the object name or the object alias as specified in the Secret\nProvider Class. If a Secret Provider Class has multiple objects, multiple files will be mounted in the Pod. Keep this in mind when creating Secret Provider Classes. Try to only mount the secrets\nneeded for a Pod instead of creating a large Secret Provider Class which contains all the secrets needed in a namespace. The Pod resulting from the Deployment below (together with the Secret Provider Class) will have two files mounted in it,\n",(0,a.jsx)(t.code,{children:"/mnt/secrets-store/bar"})," and ",(0,a.jsx)(t.code,{children:"/mnt/secrets-store/baz"}),"."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:'apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: foo\nspec:\n  selector:\n    matchLabels:\n      app: test\n  template:\n    metadata:\n      labels:\n        app: test\n    spec:\n      containers:\n        - name: foo\n          volumeMounts:\n            - name: secret-store\n              mountPath: "/mnt/secrets-store"\n              readOnly: true\n      volumes:\n        - name: secret-store\n          csi:\n            driver: secrets-store.csi.k8s.io\n            readOnly: true\n            volumeAttributes:\n              secretProviderClass: foo\n'})}),"\n",(0,a.jsxs)(t.p,{children:["Additionally, you may want to have your secrets available as environment variables. Extending the example above, the secret ",(0,a.jsx)(t.code,{children:"bar"})," is now also available as the environment variable ",(0,a.jsx)(t.code,{children:"BAR"}),":"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:'apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: foo\nspec:\n  selector:\n    matchLabels:\n      app: test\n  template:\n    metadata:\n      labels:\n        app: test\n    spec:\n      containers:\n        - name: foo\n          volumeMounts:\n            - name: secret-store\n              mountPath: "/mnt/secrets-store"\n              readOnly: true\n          env:\n            - name: BAR\n              valueFrom:\n                secretKeyRef:\n                  name: bar\n                  key: bar\n      volumes:\n        - name: secret-store\n          csi:\n            driver: secrets-store.csi.k8s.io\n            readOnly: true\n            volumeAttributes:\n              secretProviderClass: foo\n'})}),"\n",(0,a.jsx)(t.p,{children:"Note that even if you only want to access your secret via an environment variable, you still need to mount the secret store as a volume."}),"\n",(0,a.jsx)(t.h2,{id:"auto-updating-secrets",children:"Auto updating secrets"}),"\n",(0,a.jsx)(t.p,{children:"The CSI drivers sits and pools the cloud provider for changes in the secrets defined in your secretProviderClass. Depending on which cloud provider they have different default values.\nBut the CSI driver only pools the secrets if you have a pod that is actively using the secret defined in the cloud."}),"\n",(0,a.jsxs)(t.p,{children:["This can cause issues if you are using CSI driver in a cronjob and that secret don't have any other long running pods that mounts it.\nFor example a cronjob that runs for under 2 minutes ",(0,a.jsx)(t.strong,{children:"is not"})," guaranteed to get the latest updated secret from the cloud provider.\nAnd even if you have a longer running cronjob that would get a update you would then have to restart that job to make sure that you got the latest secret if someone have updated the secret."]}),"\n",(0,a.jsx)(t.p,{children:"To workaround this issue you have to create a pod that uses the same secret to make sure that the secret is up to date.\nAll this long running pod needs to do is to mount the secret and sleep."}),"\n",(0,a.jsx)(t.p,{children:"Below you can find a suggestion on how to that:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-.yaml",children:'apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: foo\nspec:\n  selector:\n    matchLabels:\n      app: test\n  template:\n    metadata:\n      labels:\n        app: test\n    spec:\n      containers:\n        - name: busybox\n          image: busybox:latest\n          command: ["/bin/sh", "-c", "--"]\n          args: ["while true; do sleep 30; done;"]\n          tty: true\n          volumeMounts:\n            - name: secret-store\n              mountPath: "/mnt/secrets-store"\n              readOnly: true\n          env:\n            - name: BAR\n              valueFrom:\n                secretKeyRef:\n                  name: bar\n                  key: bar\n      volumes:\n        - name: secret-store\n          csi:\n            driver: secrets-store.csi.k8s.io\n            readOnly: true\n            volumeAttributes:\n              secretProviderClass: foo\n'})}),"\n",(0,a.jsx)(t.h2,{id:"cloud-providers",children:"Cloud Providers"}),"\n",(0,a.jsx)(t.h3,{id:"azure",children:"Azure"}),"\n",(0,a.jsxs)(t.p,{children:["The Azure provider for the CSI driver requires some configuration to work, as it is possible to have multiple Azure Key Vaults. For that reason the Secret Provider Class has to specify the name of the\nKey Vault and the tenant id where the CSI Driver can find the secret. Additionally it is important to set ",(0,a.jsx)(t.code,{children:'usePodIdentity: "true"'})," as authentication to the Azure API will be done with the help of\nAAD Pod Identity."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:'apiVersion: secrets-store.csi.x-k8s.io/v1\nkind: SecretProviderClass\nmetadata:\n  name: connection-string-test\nspec:\n  provider: azure\n  parameters:\n    usePodIdentity: "true"\n    keyvaultName: "kvname"\n    objects: |\n      array:\n        - |\n          objectName: connectionstring\n          objectType: secret\n    tenantId: "11111111-1111-1111-1111-111111111111"\n'})}),"\n",(0,a.jsxs)(t.p,{children:["To use the Secret Provider Class simply mount it as a volume in the Pod where you want to read the secret. The only extra configuration that is required is setting the label ",(0,a.jsx)(t.code,{children:"aadpodidbinding"})," to the\nname of the Azure Identity. This is required as the CSI Driver will assume the Pods identity when authenticating with the Azure API. Without this label the fetching of the secret will fail."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:'apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: connection-string-test\n  namespace: tenant\nspec:\n  selector:\n    matchLabels:\n      app: connection-string-test\n  template:\n    metadata:\n      labels:\n        app: connection-string-test\n        aadpodidbinding: tenant\n    spec:\n      containers:\n        - name: connection-string-test\n          image: alpine:latest\n          volumeMounts:\n            - name: secret-store\n              mountPath: "/mnt/secrets-store"\n              readOnly: true\n      volumes:\n        - name: secret-store\n          csi:\n            driver: secrets-store.csi.k8s.io\n            readOnly: true\n            volumeAttributes:\n              secretProviderClass: connection-string-test\n'})}),"\n",(0,a.jsx)(t.h3,{id:"aws",children:"AWS"}),"\n",(0,a.jsxs)(t.p,{children:["There are two secret store services in AWS that is supported by the CSI Driver, ",(0,a.jsx)(t.a,{href:"https://aws.amazon.com/secrets-manager/",children:"AWS Secret Manager"})," and ",(0,a.jsx)(t.a,{href:"https://docs.aws.amazon.com/systems-manager/latest/userguide/systems-manager-parameter-store.html",children:"AWS System Manager Parameter\nStore"}),". Both services have their own pros and cons in regards to features and pricing, but in the\nend both services deliver the same features in the cluster. The example below shows how to read the secret ",(0,a.jsx)(t.code,{children:"application/connection-string-test/connectionstring"})," with examples for both Secret Manager\nand System Manager Parameter Store."]}),"\n",(0,a.jsxs)(t.p,{children:["Create an IAM role which gives permission to read the specific secret, note that the full ARN path including the secret name is included in the resource field. This is to limit secret acccess for the\napplication as there is only a single service instance per account and region. The CSI Driver also requires the ",(0,a.jsx)(t.code,{children:"secretsmanager:ListSecrets"})," permission or ",(0,a.jsx)(t.code,{children:"ssm:DescribeParameters"})," to function\nproperly. It will not be able to read any secret values with this permission, just list them."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-hcl",children:'data "aws_iam_policy_document" "db_connection_string" {\n  statement {\n    effect = "Allow"\n    actions = [\n      "secretsmanager:ListSecrets",\n    ]\n    resources = ["*"]\n  }\n  statement {\n    effect = "Allow"\n    actions = [\n      "secretsmanager:GetSecretValue",\n      "secretsmanager:DescribeSecret",\n      "secretsmanager:GetResourcePolicy",\n      "secretsmanager:ListSecretVersionIds"\n    ]\n    resources = ["arn:aws:secretsmanager:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:secret:application/connection-string-test/connectionstring"]\n  }\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:"or"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-hcl",children:'data "aws_iam_policy_document" "db_connection_string" {\n  statement {\n    effect = "Allow"\n    actions = [\n      "ssm:DescribeParameters",\n    ]\n    resources = ["*"]\n  }\n  statement {\n    effect = "Allow"\n    actions = [\n      "ssm:GetParameter",\n      "ssm:GetParameters",\n    ]\n    resources = ["arn:aws:ssm:${data.aws_region.current.name}:${data.aws_caller_identity.current.account_id}:parameter/db-*"]\n  }\n}\n'})}),"\n",(0,a.jsx)(t.p,{children:"Complete the configuration by passing the policy document to the IRSA module which will create the IAM policy and role, this should be the same for both Secret Manager and System Manager Parameter\nStore."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-hcl",children:'module "irsa_test" {\n  source = "github.com/xenitab/terraform-modules//modules/aws/irsa?ref=2021.08.9"\n\n  name = "irsa-test"\n  oidc_providers = [\n    for v in var.oidc_urls :\n    {\n      url = v\n      arn = aws_iam_openid_connect_provider.this[v].arn\n    }\n  ]\n  kubernetes_namespace       = "tenant"\n  kubernetes_service_account = "connection-string-test"\n  policy_json                = data.aws_iam_policy_document.get_login_profile.json\n}\n'})}),"\n",(0,a.jsxs)(t.p,{children:["After the IAM role and policy have been created a Secret Provider Class has to be created specifying the secrets that should be read. Make sure to specify the correct object type, it should either be\n",(0,a.jsx)(t.code,{children:"secretsmanager"})," or ",(0,a.jsx)(t.code,{children:"ssmparameter"}),". Note the configuration of ",(0,a.jsx)(t.code,{children:"objectAlias"})," for the object. This is required as the secret name contains the character ",(0,a.jsx)(t.code,{children:"/"})," in the name. By default the CSI Driver uses\nthe name as the file name, which would cause issues as this is not permitted in Linux. The solution is to give the secret an alias instead."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:'apiVersion: secrets-store.csi.x-k8s.io/v1\nkind: SecretProviderClass\nmetadata:\n  name: connection-string-test\n  namespace: tenant\nspec:\n  provider: aws\n  parameters:\n    objects: |\n      - objectName: "application/connection-string-test/connectionstring"\n        objectType: "secretsmanager" | "ssmparameter"\n        objectAlias: "connectionstring"\n  secretObjects:\n    - data:\n        - key: password\n          objectName: "connectionstring"\n      secretName: connectionstring\n      type: Opaque\n'})}),"\n",(0,a.jsx)(t.p,{children:"Create a deployment which mounts the secret from the remote service. The secret is mounted as a volume in the Pod and will be populated with the value stored in the remote service. It is important\nthat the Service Account is configured properly as the CSI Driver will assume the Pod's role when fetching the secret value."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:'apiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: connection-string-test\n  namespace: tenant\n  annotations:\n    eks.amazonaws.com/role-arn: arn:aws:iam::111111111111:role/connection-string-test\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: connection-string-test\n  namespace: tenant\nspec:\n  selector:\n    matchLabels:\n      app: connection-string-test\n  template:\n    metadata:\n      labels:\n        app: connection-string-test\n    spec:\n      serviceAccountName: connection-string-test\n      containers:\n        - name: connection-string-test\n          image: alpine:latest\n          volumeMounts:\n            - name: secret-store\n              mountPath: "/mnt/secrets-store"\n              readOnly: true\n      volumes:\n        - name: secret-store\n          csi:\n            driver: secrets-store.csi.k8s.io\n            readOnly: true\n            volumeAttributes:\n              secretProviderClass: connection-string-test\n'})}),"\n",(0,a.jsx)(t.h2,{id:"automatic-reloading",children:"Automatic Reloading"}),"\n",(0,a.jsx)(t.p,{children:"A Pod will get the latest version of the Secret Provider Class when started. The CSI Driver will poll the secret and update when the secret value is updated. However the Pod will not be\nupdated as this would require the application to be able to restart the process and read the file instead. The Pod will not receive the new value until a new instance of the Pod is created. This could\nbecome annoying for situations where the secret value may change often or there are a lot of secrets being read."}),"\n",(0,a.jsxs)(t.p,{children:["The solution in XKS is to configure the Secret Provider Class to annotate the Pod to be recreated when the Secret value is updated. The Pod recreation is done with the\n",(0,a.jsx)(t.a,{href:"https://github.com/stakater/Reloader",children:"Reloader"})," project which is present in all XKS clusters. Reloader works by adding an annotation with the key ",(0,a.jsx)(t.code,{children:"secret.reloader.stakater.com/reload"}),", where the value\nis the name of the secret. If you need to recreate your Pod when any of multiple secrets are changed, use comma-separated values:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:'secret.reloader.stakater.com/reload: "foo,bar"\n'})}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"When using an object alias the object name in the secrets objects refers to the alias and not to the original object name."}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Below is an example of creating a Service Provider Class which also creates a Kubernetes Secret, there is no need to actually use the created secret but in the example below it is mounted as an environment variable."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:'apiVersion: secrets-store.csi.x-k8s.io/v1\nkind: SecretProviderClass\nmetadata:\n  name: application\n  namespace: tenant\nspec:\n  provider: <provider>\n  parameters:\n    objects: |\n      - objectName: "foo"\n        objectType: "<type>"\n  secretObjects:\n    - data:\n        - key: bar\n          objectName: foo\n      secretName: foo\n      type: Opaque\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: application\n  namespace: tenant\nspec:\n  selector:\n    matchLabels:\n      app: application\n  template:\n    metadata:\n      annotations:\n        secret.reloader.stakater.com/reload: "foo"\n      labels:\n        app: application\n    spec:\n      serviceAccountName: application\n      containers:\n        - name: application\n          image: alpine:latest\n          env:\n            - name: BAR\n              valueFrom:\n                secretKeyRef:\n                  name: foo\n                  key: bar\n          volumeMounts:\n            - name: secret-store\n              mountPath: "/mnt/secrets-store"\n              readOnly: true\n      volumes:\n        - name: secret-store\n          csi:\n            driver: secrets-store.csi.k8s.io\n            readOnly: true\n            volumeAttributes:\n              secretProviderClass: foo\n'})}),"\n",(0,a.jsx)(t.h2,{id:"troubleshooting",children:"Troubleshooting"}),"\n",(0,a.jsx)(t.p,{children:"There are a lot of things that can go wrong when configuring Secrets. Here are some pointers for things to check:"}),"\n",(0,a.jsxs)(t.h3,{id:"did-you-forget-to-declare-the-secretproviderclass",children:["Did you forget to declare the ",(0,a.jsx)(t.code,{children:"SecretProviderClass"}),"?"]}),"\n",(0,a.jsx)(t.p,{children:"Remember, getting access to your secrets consists of 2 separate parts:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["a ",(0,a.jsx)(t.code,{children:"SecretProviderClass"}),", which tells Kubernetes where it can get the stored secret"]}),"\n",(0,a.jsxs)(t.li,{children:["a mount of the provided ",(0,a.jsx)(t.code,{children:"secrets-store"})," for your deployment"]}),"\n"]}),"\n",(0,a.jsx)(t.h3,{id:"verifying-your-loaded-yaml",children:"Verifying your loaded YAML"}),"\n",(0,a.jsxs)(t.p,{children:["By running ",(0,a.jsx)(t.code,{children:"kubectl get secretproviderclasspodstatuses -o yaml"})," you can get a lot of information about if and how your secrets got correctly loaded. Check here first!\nFor example, look out to see that all the secrets you expect to see are available, and that they are mounted:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:"status:\n  mounted: true\n"})}),"\n",(0,a.jsx)(t.h3,{id:"is-your-key-vault-correctly-configured-and-does-the-pod-have-access-to-it",children:"Is your key vault correctly configured, and does the pod have access to it?"}),"\n",(0,a.jsxs)(t.p,{children:["Speaking from experience, it is all too easy to setup access to the wrong key vault. If you are accessing the right key vault and you are using Azure, double check that\n",(0,a.jsx)(t.code,{children:'usePodIdentity: "true"'})," is set on the ",(0,a.jsx)(t.code,{children:"SecretProviderClass"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["You also need to make sure that the metadata of your deployment's ",(0,a.jsx)(t.code,{children:"template"})," section contains a declaration of which ",(0,a.jsx)(t.code,{children:"aadpodidbinding"})," to use (which is always your tenant's name):"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:"apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: connection-string-test\n  namespace: tenant\nspec:\n  selector:\n    matchLabels:\n      app: connection-string-test\n  template:\n    metadata:\n      labels:\n        app: connection-string-test\n        aadpodidbinding: tenant\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Please also verify that ",(0,a.jsx)(t.code,{children:"aadpodidbinding"})," is set on the ",(0,a.jsx)(t.code,{children:"metadata"})," section under ",(0,a.jsx)(t.code,{children:"template"})," and not on the root ",(0,a.jsx)(t.code,{children:"metadata"})," section. The latter will not work."]}),"\n",(0,a.jsx)(t.h3,{id:"are-your-environment-variables-correctly-set",children:"Are your environment variables correctly set?"}),"\n",(0,a.jsxs)(t.p,{children:["If you want to load your secret as an environment variable, remember that it ",(0,a.jsx)(t.strong,{children:"still needs to be mounted as a volume"}),". Also, don't forget that it doesn't automatically become available as a\ncorresponding environment variable, you still need to load it explicitly, like this:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-yaml",children:"env:\n  - name: BAR\n    valueFrom:\n      secretKeyRef:\n        name: foo\n        key: bar\n"})}),"\n",(0,a.jsx)(t.h3,{id:"are-your-secret-names-matching-the-names-in-the-reloader-statement",children:"Are your secret names matching the names in the reloader statement?"}),"\n",(0,a.jsxs)(t.p,{children:["If this is not the case, you will see errors when running ",(0,a.jsx)(t.code,{children:"kubectl describe <podname>"}),". A well-behaved reloader will emit events that look like this:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-bash",children:"Normal SecretRotationComplete 4m22s (x889 over 29h) csi-secrets-store-rotation successfully rotated K8s secret <secret-name>\n"})})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}}}]);